import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TLS
{
    static final byte[] PRESHARED_SECRET = {0x50, 0x52, 0x45, 0x53, 0x48, 0x41,
        0x52, 0x45, 0x44, 0x5f, 0x53, 0x45, 0x43, 0x52, 0x45, 0x54};

    public static void main(String[] args) throws Exception {
        /*
         * An instance of RSA is generated by the server, with a 2048-bit public
         * key.
         */
        KeyPairGenerator rsa = KeyPairGenerator.getInstance("RSA");
        rsa.initialize(2048);
        KeyPair rsaKeyPair = rsa.generateKeyPair();
        PublicKey rsaPublicKey = rsaKeyPair.getPublic();
        PrivateKey rsaPrivateKey = rsaKeyPair.getPrivate();
        byte[] encodedRsaPublicKey = rsaPublicKey.getEncoded();

        /*
         * In the absence of a certificate authority, HMAC-SHA256 is used by the
         * server to sign its RSA public key using a pre-shared secret that both
         * the client and server have already.
         *
         * The server sends the encoded RSA public key and the message
         * authentication code (MAC) to the client. The client verifies the MAC
         * by performing this same calculation with its own pre-shared secret
         * (should be identical) and comparing the MAC it generates with the MAC
         * the server sent.
         */
        Mac hmac = Mac.getInstance("HmacSHA256");
        SecretKeySpec hmacKey = new SecretKeySpec(PRESHARED_SECRET, "HmacSHA256");
        hmac.init(hmacKey);
        // byte[] mac = hmac.doFinal(encodedRsaPublicKey);

        /*
         * If the MACs match, the client generates a master secret and encrypts
         * it with RSA, using the server's decoded RSA public key as the
         * encryption key.
         */
        PublicKey decodedRsaPublicKey = KeyFactory
            .getInstance("RSA")
            .generatePublic(new X509EncodedKeySpec(encodedRsaPublicKey));
        SecureRandom random = SecureRandom.getInstanceStrong();
        byte[] masterSecret = new byte[128];
        random.nextBytes(masterSecret);
        Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
        cipher.init(Cipher.ENCRYPT_MODE, decodedRsaPublicKey);
        byte[] encryptedMS = cipher.doFinal(masterSecret);

        /*
         * The server decrypts the master secret using its RSA private key and
         * then generates the AES secret key using a key derivation function
         * (KDF); we simply use a cryptographic hash function.
         *
         * Here, SHA-256 is used to generate a 256-bit AES secret key by
         * producing a message digest of the master secret.
         *
         * The client can also generate this key since they generated the master
         * secret in the first place.
         */
        cipher.init(Cipher.DECRYPT_MODE, rsaPrivateKey);
        byte[] decryptedMS = cipher.doFinal(encryptedMS);
        if (masterSecret.length == decryptedMS.length) {
            for (int i = 0; i < masterSecret.length; i++) {
                if (masterSecret[i] != decryptedMS[i]) {
                    throw new Exception("Master secrets don't match.");
                }
            }
        } else {
            throw new Exception("Master secrets don't match.");
        }
        MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
        byte[] aesKeyBytes = sha256.digest(decryptedMS);
        SecretKeySpec aesKey = new SecretKeySpec(aesKeyBytes, "AES");

        /*
         * AES-256-GCM is used to encrypt a message. The ciphertext,
         * initialization vector (IV, sometimes called a nonce), and additional
         * associated data (AAD) is sent over.
         *
         * GCM uses an unencrypted AAD to generate a tag after encryption, which
         * is appended to the ciphertext. The tag is validated during decryption
         * using the same AAD.
         *
         * The benefit AES-256-GCM has over AES-256-CBC with HMAC-SHA256 is that
         * GCM is parallelizable and therefore more efficient with
         * multithreading. However, GCM requires a different random IV for every
         * single plaintext.
         */
        String plaintext = "Hello world!";
        byte[] aad = "authenticated but unencrypted data".getBytes(StandardCharsets.UTF_8);
        byte[] iv = new byte[12];
        random = new SecureRandom();
        random.nextBytes(iv);
        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);
        cipher = Cipher.getInstance("AES/GCM/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, aesKey, gcmSpec);
        cipher.updateAAD(aad);
        byte[] ciphertext = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));

        /*
         * Decrypting the message with the ciphertext, IV (in gcmSpec), and AAD
         * using AES-256-GCM.
         */
        cipher.init(Cipher.DECRYPT_MODE, aesKey, gcmSpec);
        cipher.updateAAD(aad);
        byte[] decrypted = cipher.doFinal(ciphertext);
        String recovered = new String(decrypted, StandardCharsets.UTF_8);
        if (!plaintext.equals(recovered)) {
            throw new Exception("Plaintexts don't match.");
        }
    }
}
